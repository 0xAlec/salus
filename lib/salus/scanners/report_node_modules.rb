require 'salus/scanners/base'
require 'cyclonedx/base'

# Report node module dependencies.

module Salus::Scanners
  class ReportNodeModules < Base
    class ParseError < StandardError; end

    SCOPE_REQUIRED = Cyclonedx::Base::SCOPE_REQUIRED
    SCOPE_OPTIONAL = Cyclonedx::Base::SCOPE_OPTIONAL
    DEFAULT_YARN_REGISTRY = "https://registry.yarnpkg.com".freeze

    def run
      # A lockfile is the most definitive source of truth for what will run
      # in production. It also lists the dependencies of dependencies.
      # We preference parsing dependencies in the following order:
      #  - yarn.lock
      #  - package-lock.json
      # We will also always parse package.json if it's present since there is some unique data.

      if @repository.yarn_lock_present?
        record_dependencies_from_yarn_lock

        if @repository.package_json_present?
          record_dependencies_from_package_json(record_modules: false)
        end
      elsif @repository.package_lock_json_present?
        record_dependencies_from_package_lock_json

        if @repository.package_json_present?
          record_dependencies_from_package_json(record_modules: false)
        end
      elsif @repository.bower_json_present?
        record_dependencies_from_bower_json

        if @repository.package_json_present?
          record_dependencies_from_package_json(record_modules: false)
        end
      elsif @repository.package_json_present?
        record_dependencies_from_package_json(record_modules: true)
      else
        raise InvalidScannerInvocationError,
              'Cannot report on Node modules without package.json, '\
                'package-lock.json or yarn.lock files.'
      end
    end

    def should_run?
      @repository.yarn_lock_present? ||
        @repository.package_lock_json_present? ||
        @repository.bower_json_present? ||
        @repository.package_json_present?
    end

    def self.supported_languages
      ['javascript']
    end

    private

    def report_legacy_yarn
      shell_return = run_shell("bin/parse_yarn_lock #{@repository.path_to_repo}/yarn.lock",
                               chdir: nil)

      unless shell_return.success?
        raise ParseError, "Failed to parse yarn.lock file: #{shell_return.stderr}"
      end

      yarn_lock = JSON.parse(shell_return.stdout)

      if yarn_lock['type'] != 'success'
        raise ParseError, '@yarnpkg/lockfile failed to parse the yarn.lock file.'
      end

      # At this point we only have block of dependencies left. Record all.
      yarn_lock['object'].each do |dependency, info|
        # The dependency will be the <package name>@<version or location>.
        parts = dependency.scan(/(.*)@(.*)/)[0]
        name = parts[0]
        version_or_location = parts[1]

        # If there is a value for "resolved" then this is the source.
        # Otherwise, it was part of the dependency and referenced directly from local file.
        source = info['resolved']
        source ||= version_or_location
        version = info['version']
        puts "#{name}, #{version}, #{source}"
        record_node_module(
          name: name,
          version: version,
          source: source,
          dependency_file: 'yarn.lock'
        )
      end
    end

    def parse_updated_yarn_source
      source = DEFAULT_YARN_REGISTRY
      shell_return = run_shell("yarn config --json")
      if shell_return.success?
        configs = shell_return.stdout.split("\n")
        configs.each do |config|
          cfg = JSON.parse(config)
          source = cfg.fetch("effective") if cfg.fetch("key", "") == "npmRegistryServer"
        end
      end
      source
    end

    def parse_updated_yarn_deps
      all_dependencies = []
      shell_return = run_shell("yarn info --json --recursive")
      if shell_return.success?
        dependencies = shell_return.stdout.split("\n")
        dependencies.each do |dependency|
          dependency = JSON.parse(dependency)
          name = dependency.dig("value")
          version = dependency.dig("children", "Version")

          all_dependencies.append({
                                    "name": (name.match(/.+?(?=@npm)/).to_s if name.present?),
                                    "version": version
                                  })
        end
      end
      all_dependencies
    end

    def report_updated_yarn
      source = parse_updated_yarn_source
      dependencies = parse_updated_yarn_deps
      dependencies.each do |dependency|
        puts dependency
        record_node_module(
          name: dependency["name"],
          version: version["version"],
          source: source,
          dependency_file: 'yarn.lock'
        )
      end
    end

    def record_dependencies_from_yarn_lock
      version = run_shell("yarn --version").stdout
      if Gem::Version.new(version) >= Gem::Version.new('2.0.0')
        report_updated_yarn
      elsif Gem::Version.new(version) < Gem::Version.new('2.0.0')
        report_legacy_yarn
      end
    end

    def record_dependency_from_package_lock_json(dependency, data, dev_flag)
      record_node_module(
        name: dependency,
        version: data['version'],
        source: "#{data['resolved']}#{"##{data['integrity']}" if data['integrity']}",
        dependency_file: 'package-lock.json',
        scope: dev_flag ? SCOPE_OPTIONAL : SCOPE_REQUIRED
      )
    end

    def record_dependencies_from_package_lock_json
      include_dev_dependencies = @config.fetch('include_dev_deps', true)
      package_lock = JSON.parse(@repository.package_lock_json)

      # Record the lock file version.
      report_info(
        :package_lock_version,
        package_lock.fetch('lockfileVersion', '<unknown>').to_s
      )

      # Record each dependency.
      package_lock['dependencies']&.each do |dependency, data|
        is_dev = data['dev'] || false

        if !is_dev || is_dev && include_dev_dependencies
          record_dependency_from_package_lock_json(dependency, data, is_dev)

          # Handling recursive dependencies.
          if data.key?("dependencies")
            nested_dependencies = data.dig("dependencies")
            nested_dependencies.each do |nested_dependency, nested_data|
              nested_is_dev = nested_data['dev'] || false
              if !nested_is_dev || nested_is_dev && include_dev_dependencies
                record_dependency_from_package_lock_json(nested_dependency,
                                                         nested_data, nested_is_dev)
              end
            end
          end

        end
      end
    end

    def record_dependencies_from_bower_json
      begin
        packages = JSON.parse(@repository.bower_json)
      rescue JSON::ParserError => e
        error_msg = "Failed to parse bower.json when recording bower dependencies."
        bugsnag_notify(e.message)
        report_error(error_msg)
        return
      end
      # Record if custom registry is defined in .bowerrc
      # Supports single and multiple registry -
      # {"registry": "https://registry.bower.io"}
      # {"registry": {"search": ["http://localhost:9000","https://registry.bower.io"] }}
      sources = 'https://registry.bower.io'
      if @repository.bowerrc_present?
        begin
          file = JSON.parse(@repository.bowerrc)
        rescue JSON::ParserError => e
          error_msg = "Failed to parse .bowerrc when recording bower dependencies."
          bugsnag_notify(e.message)
          report_error(error_msg)
        end
        if file.is_a?(Hash)
          if file.key?("registry") && file["registry"].is_a?(Hash) &&
              file.dig("registry", "search").is_a?(Array)
            sources = file.dig("registry", "search").join(',')
          elsif file.key?("registry") && file["registry"].is_a?(String)
            sources = file.dig("registry")
          end
        end
      end

      # Record dependencies, version from bower.json
      packages['dependencies']&.each do |name, version|
        record_node_module(
          name: name,
          version: version,
          source: sources,
          dependency_file: 'bower.json'
        )
      end
    end

    def record_dependencies_from_package_json(record_modules: true)
      packages = JSON.parse(@repository.package_json)

      # Record the npm and node versions.
      if packages['engines']
        node_version = packages['engines']['node']
        npm_version = packages['engines']['npm']
        report_info(:package_json_node_version, node_version) unless node_version.nil?
        report_info(:package_json_npm_version, npm_version) unless npm_version.nil?
      end

      return unless record_modules

      # Record each dependency. Start by checking for non npmjs.com sources
      sources = {}
      if @repository.npmrc_present?
        @repository.npmrc.split("\n").each do |line|
          # if the line is blank
          next if line.empty?

          # npmrc is ini formatted
          key = line.split('=')[0]
          value = line.split('=')[1]
          next unless key.start_with?('@')

          # This line has the format "@source_name:registry=https://source.com"
          sources[key.split(':')[0]] = value
        end
      end

      packages['dependencies']&.each do |name, version|
        # Resolve the source if possible from .npmrc
        source = if name.start_with?('@')
                   sections = name.split(%r{\/})
                   sources[sections[0]]
                 else
                   '<package manager default>'
                 end
        record_node_module(
          name: name,
          version: version,
          source: source,
          dependency_file: 'package.json'
        )
      end
    end

    def record_node_module(dependency_file:, name:, version:, source:, scope: SCOPE_REQUIRED)
      report_dependency(
        dependency_file,
        type: 'node_module',
        name: name,
        version: version,
        source: source,
        scope: scope
      )
    end
  end
end
